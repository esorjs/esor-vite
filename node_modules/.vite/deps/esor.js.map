{
  "version": 3,
  "sources": ["../../esor/src/lifecycle.js", "../../esor/src/globals.js", "../../esor/src/utils/dom.js", "../../esor/src/hooks/arrays.js", "../../esor/src/hooks/effects.js", "../../esor/src/hooks/signals.js", "../../esor/src/utils/parser.js", "../../esor/src/templates/reconcile.js", "../../esor/src/helpers.js", "../../esor/src/logger.js", "../../esor/src/events/events.js", "../../esor/src/templates/engine.js", "../../esor/src/templates/templates.js", "../../esor/src/templates/props.js", "../../esor/src/component.js", "../../esor/src/hooks/ref.js", "../../esor/src/hooks/memo.js", "../../esor/src/hooks/store.js"],
  "sourcesContent": ["export class Lifecycle {\n    static current;\n    #lc = new Map();\n\n    constructor() {\n        Lifecycle.current = this;\n    }\n\n    #hooks(t) {\n        return this.#lc.has(t) || this.#lc.set(t, new Set()), this.#lc.get(t);\n    }\n\n    add(t, fn) {\n        this.#hooks(t).add(fn);\n        return () => this.#lc.get(t)?.delete(fn);\n    }\n    run(t, ctx) {\n        this.#lc.get(t)?.forEach((fn) => {\n            try {\n                fn.call(ctx);\n            } catch (e) {\n                ctx._catchError(e);\n            }\n        });\n    }\n    clear(t) {\n        t ? this.#lc.delete(t) : this.#lc.clear();\n    }\n}\n\nconst getLC = () =>\n    Lifecycle.current ||\n    (() => {\n        throw \"Lifecycle not initialized\";\n    })();\n\nexport const [beforeMount, onMount, beforeUpdate, onUpdate, onDestroy] = [\n    \"beforeMount\",\n    \"mount\",\n    \"beforeUpdate\",\n    \"update\",\n    \"destroy\",\n].map((t) => (fn) => getLC().add(t, fn));\n\nexport const onEffect = (fn) => {\n    const clean = fn();\n    return (\n        (clean instanceof Function && getLC().add(\"destroy\", clean)) ||\n        (() => {})\n    );\n};\n", "// Global mutable state\nconst STATE = {\n    currentEffect: null,\n    currentComponent: null,\n    pendingEffects: new Set(),\n    isEffectsFlushing: false,\n    globalEvents: {\n        handlersByType: new Map(),\n        nextId: 0,\n    },\n};\n\nexport default STATE;\n\nexport function withCurrentComponent(component, fn) {\n    const prev = STATE.currentComponent;\n    STATE.currentComponent = component;\n    try {\n        return fn();\n    } finally {\n        STATE.currentComponent = prev;\n    }\n}\n", "export function valuesChanged(val1, val2) {\n    return !Object.is(val1, val2);\n}\n\nexport const getDocumentFragment = (e) =>\n    (e instanceof DocumentFragment && e) ||\n    e?.content?.cloneNode() ||\n    document.createDocumentFragment();\n\nexport function removeChildNodesBetween(startNode, endNode) {\n    let node = startNode.nextSibling;\n    while (node && node !== endNode) {\n        const next = node.nextSibling;\n        node.parentNode.removeChild(node);\n        node = next;\n    }\n}\n\nexport const findCommentPlaceholders = (root, attr) => {\n    const w = document.createTreeWalker(root, NodeFilter.SHOW_COMMENT);\n    let [s, e] = [null, null];\n    while (w.nextNode() && !e) {\n        const n = w.currentNode;\n        if (!s && n.nodeValue === attr) s = n;\n        else if (s && n.nodeValue === `//${attr}`) e = n;\n    }\n    return [s, e];\n};\n\nexport function setupDeclarativeShadowRoot(host) {\n    const supportsDeclarative =\n        HTMLElement.prototype.hasOwnProperty(\"attachInternals\");\n    const internals = supportsDeclarative ? host.attachInternals() : null;\n\n    if (internals?.shadowRoot) host.shadowRoot = internals.shadowRoot;\n    else host.attachShadow({ mode: \"open\" });\n}\n", "// M\u00E9todos para arrays reactivas:\nconst ARRAY_METHODS = [\n    \"map\",\n    \"filter\",\n    \"find\",\n    \"findIndex\",\n    \"slice\",\n    \"concat\",\n    \"reduce\",\n    \"every\",\n    \"some\",\n    \"includes\",\n    \"push\",\n    \"pop\",\n    \"shift\",\n    \"unshift\",\n    \"splice\",\n    \"reverse\",\n    \"sort\",\n];\n\nexport function addSignalMap(arr, read) {\n    for (const method of ARRAY_METHODS) {\n        const fn = arr[method];\n        arr[method] = (...args) => {\n            const result = fn.apply(arr, args);\n            if (result instanceof Array) {\n                result.__signalArray = true;\n                result.__signal = read;\n                result.__mapFn = args[0];\n            }\n            return result;\n        };\n    }\n    return arr;\n}\n", "import STATE from \"../globals\";\n\n/**\n * Efectos pendientes se ejecutan en microtask,\n * evitando actualizaciones sin control.\n */\nexport function flushEffects() {\n    if (STATE.isEffectsFlushing) return;\n    STATE.isEffectsFlushing = true;\n\n    Promise.resolve().then(() => {\n        const effectsToRun = new Set(STATE.pendingEffects);\n        STATE.pendingEffects.clear();\n\n        effectsToRun.forEach((effect) => {\n            if (typeof effect === \"function\") {\n                effect(); // ejecuta el efecto\n            } else {\n                // Loggear error si no es una funci\u00F3n\n                console.error(\"Non-function in flushEffects:\", effect);\n            }\n        });\n\n        STATE.isEffectsFlushing = false;\n    });\n}\n\n/**\n * useEffect: registra una funci\u00F3n \"effect\" que se re-ejecuta al cambiar\n * signals le\u00EDdos durante su ejecuci\u00F3n.\n */\nexport function useEffect(fn) {\n    const effect = () => {\n        const prevEffect = STATE.currentEffect;\n        STATE.currentEffect = effect;\n        try {\n            return fn();\n        } finally {\n            STATE.currentEffect = prevEffect;\n        }\n    };\n    effect(); // Ejecuta inmediatamente la primera vez\n    return effect;\n}\n", "import STATE from \"../globals\";\nimport { valuesChanged } from \"../utils/dom\";\nimport { addSignalMap } from \"./arrays\";\nimport { flushEffects, useEffect } from \"./effects\";\n\nlet batchDepth = 0;\nconst pendingUpdates = new Set();\n\n/**\n * useSignal: crea un valor reactivo que notifica a suscriptores (effects)\n */\nexport function useSignal(initialValue) {\n    const subscriptions = new Set();\n    let value = initialValue;\n\n    const read = () => {\n        if (STATE.currentEffect) subscriptions.add(STATE.currentEffect);\n        if (Array.isArray(value)) return addSignalMap(value, read);\n        return value;\n    };\n\n    const write = (newValue) => {\n        if (!valuesChanged(value, newValue)) return;\n        value = newValue;\n\n        if (batchDepth > 0) {\n            subscriptions.forEach((sub) => pendingUpdates.add(sub));\n            return;\n        }\n        // Actualizamos en microtask\n        queueMicrotask(() => {\n            for (const effect of subscriptions) {\n                if (typeof effect === \"function\")\n                    STATE.pendingEffects.add(effect);\n            }\n            flushEffects();\n        });\n    };\n\n    read.valueOf = () => read();\n    read.toString = () => String(read());\n    read.signal = true;\n    read.cleanup = () => {\n        subscriptions.clear();\n        value = initialValue;\n    };\n\n    return [read, write];\n}\n\n/**\n * useComputed: computa un valor derivado y se actualiza cuando cambian\n * los signals usados dentro de la funci\u00F3n `fn`.\n */\nexport function useComputed(fn) {\n    const [value, setValue] = useSignal(fn());\n    useEffect(() => {\n        const newValue = fn();\n        if (valuesChanged(value(), newValue))\n            queueMicrotask(() => setValue(newValue));\n    });\n    return value;\n}\n\n/**\n * useBatch: agrupa varias escrituras de signals en un bloque at\u00F3mico,\n * generando actualizaciones una sola vez al final.\n */\nexport function useBatch(fn) {\n    batchDepth++;\n    try {\n        return fn();\n    } finally {\n        batchDepth--;\n        if (batchDepth === 0 && pendingUpdates.size) {\n            for (const effect of pendingUpdates) {\n                STATE.pendingEffects.add(effect);\n            }\n            pendingUpdates.clear();\n            flushEffects();\n        }\n    }\n}\n", "export const escapeHTML = (value) => {\n    if (value === undefined || value === null) return \"\";\n    return value.toString().replace(\n        /[&<>'\"]/g,\n        (match) =>\n            ({\n                \"&\": \"&amp;\",\n                \"<\": \"&lt;\",\n                \">\": \"&gt;\",\n                \"'\": \"&#39;\",\n                '\"': \"&quot;\",\n                \"/\": \"&#x2F;\",\n            }[match])\n    );\n};\n\nexport function cleanAttributeValue(value) {\n    if (value === undefined || value === null) return \"\";\n\n    return String(value)\n        .replace(/^[\"']|[\"']$/g, \"\")\n        .replace(/\"/g, \"&quot;\")\n        .replace(/'/g, \"&#39;\");\n}\n", "import { bindEventsInRange } from \"../helpers\";\n\nexport function reconcileArrays(startNode, endNode, oldItems, newItems, host) {\n    oldItems = [...(oldItems || [])];\n    newItems = [...(newItems || [])];\n\n    const parent = endNode.parentNode;\n    const currentNodes = collectNodes(startNode, endNode);\n    const newNodes = createOrReuseNodes(newItems, currentNodes, oldItems);\n\n    ddiff(parent, currentNodes, newNodes, endNode);\n    bindEventsInRange(host, startNode, endNode);\n    startNode.__oldItems = [...newItems];\n}\n\nfunction collectNodes(start, end) {\n    const nodes = [];\n    let current = start.nextSibling;\n    while (current && current !== end) {\n        nodes.push(current);\n        current = current.nextSibling;\n    }\n    return nodes;\n}\n\nfunction isValidDOMNode(node) {\n    return node && node.nodeType === Node.ELEMENT_NODE;\n}\n\nfunction getNodeKey(node) {\n    if (!isValidDOMNode(node)) return null;\n    return node.getAttribute(\"data-key\");\n}\n\nfunction updateNodeContent(oldNode, newNode, oldItem, newItem) {\n    if (!oldNode || !newNode || !oldItem?.template || !newItem?.template)\n        return false;\n\n    // Normalizaci\u00F3n de nodos de texto adyacentes\n    if (oldNode.firstChild?.nodeType === 3) oldNode.normalize();\n    if (newNode.firstChild?.nodeType === 3) newNode.normalize();\n\n    // Cache de nodos de texto\n    const oldTextNodes = getTextNodes(oldNode);\n    const newTextNodes = getTextNodes(newNode);\n\n    // Chequeo temprano de longitud diferente\n    if (oldTextNodes.length !== newTextNodes.length) return false;\n\n    let updated = false;\n\n    for (let i = 0, len = oldTextNodes.length; i < len; i++) {\n        const oldText = oldTextNodes[i].textContent;\n        const newText = newTextNodes[i].textContent;\n\n        if (oldText !== newText) {\n            oldTextNodes[i].textContent = newText;\n            updated = true;\n        }\n    }\n\n    return updated;\n}\n\nfunction getTextNodes(node) {\n    const textNodes = [];\n    const walker = document.createTreeWalker(\n        node,\n        NodeFilter.SHOW_TEXT,\n        null,\n        false\n    );\n\n    let currentNode;\n    while ((currentNode = walker.nextNode())) {\n        textNodes.push(currentNode);\n    }\n\n    return textNodes;\n}\n\nfunction createOrReuseNodes(items, currentNodes, oldItems) {\n    const nodeMap = new Map();\n    const oldItemsMap = new Map();\n    const keys = [items.length];\n\n    for (let i = 0, len = currentNodes.length; i < len; i++) {\n        const key = getNodeKey(currentNodes[i]);\n        if (key) nodeMap.set(key, currentNodes[i]);\n    }\n\n    for (let i = 0, len = oldItems.length; i < len; i++) {\n        oldItemsMap.set(getItemKey(oldItems[i], i), oldItems[i]);\n    }\n\n    for (let i = 0, len = items.length; i < len; i++) {\n        keys[i] = getItemKey(items[i], i);\n    }\n\n    return items.map((item, i) => {\n        const key = keys[i];\n        const existingNode = nodeMap.get(key);\n        const oldItem = oldItemsMap.get(key);\n\n        if (existingNode?.nodeType === 1) {\n            if (!oldItem || hasChanged(oldItem, item)) {\n                const newNode = createNode(item, key);\n                if (updateNodeContent(existingNode, newNode, oldItem, item)) {\n                    copyEventAttributes(existingNode, newNode);\n                    return existingNode;\n                }\n                return newNode;\n            }\n            return existingNode;\n        }\n\n        return createNode(item, key);\n    });\n}\n\nfunction hasChanged(oldItem, newItem) {\n    if (!oldItem || !newItem) return true;\n\n    if (oldItem?.template && newItem?.template) {\n        const oldValues = extractDynamicValues(oldItem);\n        const newValues = extractDynamicValues(newItem);\n        return !areValuesEqual(oldValues, newValues);\n    }\n\n    return !areValuesEqual(oldItem, newItem);\n}\n\nfunction extractDynamicValues(item) {\n    const template = item?.template;\n    if (!template) return null;\n\n    const values = [];\n    const fragment = template.cloneNode(true); // Clonar para evitar efectos secundarios\n    const walker = document.createTreeWalker(\n        fragment,\n        NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT,\n        {\n            acceptNode(node) {\n                 if (node.nodeType === 3) {\n                     return node.textContent.trim().length > 0\n                        ? NodeFilter.FILTER_ACCEPT\n                        : NodeFilter.FILTER_SKIP;\n                }\n                return NodeFilter.FILTER_ACCEPT; // Aceptar todos los elementos\n            },\n        }\n    );\n\n    let node;\n    while ((node = walker.nextNode())) {\n        if (node.nodeType === 3) values.push(node.textContent);\n        else {\n            const attrs = node.attributes;\n            for (let i = 0, len = attrs.length; i < len; i++) {\n                const value = attrs[i].value;\n                if (value.includes(\"${\")) values[values.length] = value;\n            }\n        }\n    }\n\n    return values;\n}\n\nfunction areValuesEqual(a, b) {\n    if (a === b) return true;\n    if (!a || !b) return false;\n    if (typeof a !== typeof b) return false;\n\n    if (Array.isArray(a) && Array.isArray(b)) {\n        return (\n            a.length === b.length &&\n            a.every((val, idx) => areValuesEqual(val, b[idx]))\n        );\n    }\n\n    if (typeof a === \"object\") {\n        const keysA = Object.keys(a);\n        const keysB = Object.keys(b);\n\n        if (keysA.length !== keysB.length) return false;\n\n        return keysA.every((key) => areValuesEqual(a[key], b[key]));\n    }\n\n    return String(a) === String(b);\n}\n\nfunction copyEventAttributes(oldNode, newNode) {\n    if (!isValidDOMNode(oldNode) || !isValidDOMNode(newNode)) return;\n\n    const EVENT_PREFIX = \"data-event-\";\n\n    const attributes = oldNode.attributes;\n    for (let i = attributes.length; i--; ) {\n        const attr = attributes[i];\n        if (attr.name.lastIndexOf(EVENT_PREFIX, 0) === 0)\n            newNode.setAttribute(attr.name, attr.value);\n    }\n}\n\nfunction getItemKey(item, index) {\n    if (item?.template) {\n        const el = item.template.firstElementChild;\n        if (item.id) return `item-${item.id}`;\n        if (el && isValidDOMNode(el)) {\n            const keyAttr = el.getAttribute(\"key\");\n            if (keyAttr) return keyAttr;\n        }\n        return `template-${index}`;\n    }\n\n    if (item && typeof item === \"object\") {\n        if (item.id) return `item-${item.id}`;\n        try {\n            return `item-${index}-${JSON.stringify(item)}`;\n        } catch {\n            return `item-${index}`;\n        }\n    }\n\n    return `item-${index}-${String(item)}`;\n}\n\nfunction createNode(item, key) {\n    let node;\n\n    if (item?.template) {\n        const content = item.template.cloneNode(true);\n        node = content.firstElementChild || document.createElement(\"div\");\n    } else {\n        node = document.createElement(\"div\");\n        node.textContent = String(item);\n    }\n\n    if (isValidDOMNode(node)) {\n        node.setAttribute(\"data-key\", key);\n    }\n\n    return node;\n}\n\nfunction ddiff(parent, current, newList, refNode) {\n    let aStart = 0,\n        aEnd = current.length,\n        bStart = 0,\n        bEnd = newList.length,\n        after = (aEnd > 0 && current[aEnd - 1].nextSibling) || refNode,\n        map = null;\n\n    if (aEnd === 0) {\n        for (let i = 0; i < bEnd; i++) parent.insertBefore(newList[i], after);\n        return;\n    }\n    if (bEnd === 0) {\n        while (aStart < aEnd) parent.removeChild(current[aStart++]);\n        return;\n    }\n\n    while (aStart < aEnd || bStart < bEnd) {\n        if (current[aStart] === newList[bStart]) {\n            aStart++;\n            bStart++;\n            continue;\n        }\n\n        while (current[aEnd - 1] === newList[bEnd - 1]) {\n            aEnd--;\n            bEnd--;\n        }\n\n        if (aStart === aEnd) {\n            const node =\n                bEnd < newList.length\n                    ? bStart\n                        ? newList[bStart - 1].nextSibling\n                        : newList[bEnd - bStart]\n                    : after;\n            while (bStart < bEnd) parent.insertBefore(newList[bStart++], node);\n        } else if (bStart === bEnd) {\n            while (aStart < aEnd) {\n                if (!map || !map.has(current[aStart]))\n                    parent.removeChild(current[aStart]);\n                aStart++;\n            }\n        } else if (\n            current[aStart] === newList[bEnd - 1] &&\n            newList[bStart] === current[aEnd - 1]\n        ) {\n            const node = current[--aEnd].nextSibling;\n            parent.insertBefore(\n                newList[bStart++],\n                current[aStart++].nextSibling\n            );\n            parent.insertBefore(newList[--bEnd], node);\n            current[aEnd] = newList[bEnd];\n        } else {\n            if (!map) {\n                map = new Map();\n                for (let i = bStart; i < bEnd; i++) map.set(newList[i], i);\n            }\n            const index = map.get(current[aStart]);\n            if (index == null) {\n                parent.removeChild(current[aStart++]);\n            } else if (bStart < index && index < bEnd) {\n                let sequence = 1;\n                while (\n                    aStart + sequence < aEnd &&\n                    index + sequence < bEnd &&\n                    current[aStart + sequence] === newList[index + sequence]\n                )\n                    sequence++;\n                if (sequence > index - bStart) {\n                    const node = current[aStart];\n                    while (bStart < index)\n                        parent.insertBefore(newList[bStart++], node);\n                } else\n                    parent.replaceChild(newList[bStart++], current[aStart++]);\n            } else aStart++;\n        }\n    }\n}\n", "import STATE, { withCurrentComponent } from \"./globals\";\nimport { handleSignalBinding } from \"./templates/templates\";\nimport { findCommentPlaceholders } from \"./utils/dom\";\nimport { reconcileArrays } from \"./templates/reconcile\";\nimport { useEffect } from \"./hooks/effects\";\n\nexport function bindSignalToElement(instance, signal, updateFn) {\n    const effect = useEffect(() => {\n        if (instance._isUpdating) return;\n        instance._isUpdating = true;\n        try {\n            updateFn(signal());\n        } finally {\n            instance._isUpdating = false;\n        }\n    });\n    instance._cleanup.add(effect);\n}\n\nexport function bindEventsInRange(instance, startNode, endNode) {\n    const { shadowRoot } = instance;\n    const elements = getElementsInRange(shadowRoot, startNode, endNode);\n    bindEvents(instance, elements);\n}\n\nexport function getElementsInRange(shadowRoot, startNode, endNode) {\n    const elements = [];\n    const walker = document.createTreeWalker(\n        shadowRoot,\n        NodeFilter.SHOW_ELEMENT,\n        null\n    );\n\n    if (!startNode && !endNode) {\n        while (walker.nextNode()) elements.push(walker.currentNode);\n    } else {\n        const startPoint = startNode?.nextSibling || shadowRoot.firstChild;\n        if (!startPoint) return elements;\n\n        walker.currentNode = startPoint;\n        do {\n            if (walker.currentNode === endNode) break;\n            elements.push(walker.currentNode);\n        } while (walker.nextNode());\n    }\n\n    return elements;\n}\n\nexport function bindEvents(instance, elements) {\n    for (const el of elements) {\n        for (const attr of Array.from(el.attributes)) {\n            if (!attr.name.startsWith(\"data-event-\")) continue;\n            const event = attr.name.replace(\"data-event-\", \"\");\n            const handlerId = parseInt(attr.value, 10);\n\n            // Verificar si el handler a\u00FAn existe antes de vincular\n            const eventHandler = STATE.globalEvents.handlersByType\n                .get(event)\n                ?.get(handlerId);\n\n            if (typeof eventHandler === \"function\") {\n                el.addEventListener(event, (...args) =>\n                    withCurrentComponent(instance, () =>\n                        eventHandler.call(instance, ...args)\n                    )\n                );\n                el.removeAttribute(attr.name);\n            }\n        }\n    }\n}\n\nexport function setupSignals(instance, signals) {\n    if (!signals) return;\n    signals.forEach(({ type, signal, bindAttr, attributeName }) => {\n        if (type === \"attribute\") {\n            const el = instance.shadowRoot.querySelector(`[${bindAttr}]`);\n            if (!el) return;\n            el.removeAttribute(bindAttr);\n            bindSignalToElement(instance, signal, (val) => {\n                const strVal = String(val);\n                if (el.getAttribute(attributeName) !== strVal)\n                    el.setAttribute(attributeName, strVal);\n            });\n        } else if (type === \"array\") {\n            const [startNode, endNode] = findCommentPlaceholders(\n                instance.shadowRoot,\n                bindAttr\n            );\n            if (!startNode || !endNode) return;\n            bindSignalToElement(instance, signal, (newVal) => {\n                const oldVal = startNode.__oldItems || [];\n                reconcileArrays(\n                    startNode,\n                    endNode,\n                    oldVal,\n                    Array.isArray(newVal) ? newVal : [],\n                    instance\n                );\n            });\n        } else if (type === \"text\" || type === \"expression\") {\n            handleSignalBinding({ host: instance, type, signal, bindAttr });\n        }\n    });\n}\n\nexport function setupRefs(instance, refs) {\n    if (!refs) return;\n    for (const [i, refFn] of refs.entries()) {\n        const el = instance.shadowRoot.querySelector(`[data-ref-${i}]`);\n        if (!el) continue;\n        el.removeAttribute(`data-ref-${i}`);\n        refFn(el);\n    }\n}\n", "import STATE from \"./globals\";\n\nconst STYLES = {\n    info: { color: \"#0066cc\", icon: \"\u2139\uFE0F\" },\n    warn: { color: \"#FFA500\", icon: \"\u26A0\uFE0F\" },\n    error: { color: \"#FF0000\", icon: \"\uD83D\uDEAB\" },\n};\n\nconst log = (type = \"info\", message = \"\", ...args) => {\n    if (!STYLES[type]) type = \"info\";\n\n    console.groupCollapsed(\n        `%c[ESOR ${STYLES[type].icon}${capitalize(type)}] ${message}`,\n        `color: ${STYLES[type].color}; font-weight: bold;`\n    );\n\n    console[type]({\n        message,\n        component: STATE.currentComponent?.constructor?.name || \"Unknown\",\n        time: new Date().toISOString(),\n        data: args.length ? args : undefined,\n    });\n\n    console[type === \"error\" ? \"trace\" : \"debug\"]();\n    console.groupEnd();\n};\n\nconst capitalize = (s) => (s ? s.charAt(0).toUpperCase() + s.slice(1) : \"\");\n\nexport const info = (...args) => log(\"info\", ...args);\nexport const warn = (...args) => log(\"warn\", ...args);\nexport const error = (...args) => log(\"error\", ...args);\n", "import STATE from \"../globals\";\nimport { error } from \"../logger\";\n\nconst eventCache = new Map();\n\nexport function registerEvent(type, handler) {\n    if (!type || typeof handler !== \"function\") {\n        error(\"Invalid event registration parameters\");\n        return -1;\n    }\n\n    let typeCache = eventCache.get(type);\n    if (!typeCache) {\n        typeCache = new Map();\n        eventCache.set(type, typeCache);\n    }\n\n    let handlers = STATE.globalEvents.handlersByType.get(type);\n    if (!handlers) {\n        handlers = new Map();\n        STATE.globalEvents.handlersByType.set(type, handlers);\n    }\n\n    const id = STATE.globalEvents.nextId++;\n\n    // Registrar en el componente actual si existe\n    const comp = STATE.currentComponent;\n    if (comp) comp._eventIds.push({ type, id });\n\n    handlers.set(id, handler);\n    typeCache.set(id, handler);\n\n    return id;\n}\n\nexport function clearEventHandler(type, id) {\n    const handlers = STATE.globalEvents.handlersByType.get(type);\n    if (handlers) {\n        handlers.delete(id);\n        if (handlers.size === 0) STATE.globalEvents.handlersByType.delete(type);\n\n        const typeCache = eventCache.get(type);\n        if (typeCache) {\n            typeCache.delete(id);\n            if (typeCache.size === 0) eventCache.delete(type);\n        }\n    }\n}\n\nexport function useEmit(name, detail) {\n    const comp = STATE.currentComponent;\n    if (!comp) {\n        error(\"useEmit must be used within a component\");\n        return null;\n    }\n\n    const event = new CustomEvent(name, {\n        detail,\n        bubbles: true,\n        composed: true,\n        cancelable: true,\n    });\n\n    event.__esor = {\n        name,\n        detail,\n        receivedBy: [],\n        timestamp: Date.now(),\n    };\n\n    comp.dispatchEvent(event);\n    return event;\n}\n", "import { registerEvent } from \"../events/events\";\nimport { escapeHTML } from \"../utils/parser\";\n\nconst attrReg = /\\s(\\w[\\w-]*)=([\"'])?(?:(?!\\2).)*$/;\nconst refReg = /ref=([\"'])?\\s*$/;\nconst evtReg = /(@\\w+)=([\"'])?\\s*$/;\nconst qReg = /([\"'])\\s*$/;\nconst rawTags = /^(script|style|textarea|title)$/i;\n\nconst trimQuote = (s) => s.replace(qReg, \"\");\nconst getQuote = (s) => (s.charAt(s.length - 1) === '\"' ? '\"' : \"'\");\nexport const isTemplateObject = (o) => o && typeof o === \"object\" && o.template;\n\nfunction injectRef(fn, hStr, i, refs) {\n    const q = getQuote(hStr);\n    refs.set(i, fn);\n    return hStr.replace(refReg, `data-ref-${i}=${q}true${q}`);\n}\nfunction injectEvent(fn, eType, hStr) {\n    const q = getQuote(hStr);\n    const id = registerEvent(eType, fn);\n    fn.isEventHandler = true;\n    return hStr.replace(evtReg, `data-event-${eType}=${q}${id}${q}`);\n}\nfunction injectSignalAttr(val, aName, hStr, sIdx, signals) {\n    hStr = trimQuote(hStr);\n    const q = getQuote(hStr);\n    const initVal = typeof val === \"function\" ? val() : val;\n    const escVal = rawTags.test(aName) ? String(initVal) : escapeHTML(initVal);\n    const bindAttr = `data-bind-${sIdx}`;\n    hStr += `${escVal} '' ${bindAttr}=${q}true${q}`;\n    signals.set(sIdx, {\n        type: \"attribute\",\n        signal: val,\n        attributeName: aName,\n        bindAttr,\n    });\n    return hStr;\n}\nfunction injectExpr(val, isFn, hStr, sIdx, signals) {\n    const bA = `data-expr-${sIdx}`;\n    signals.set(sIdx, {\n        type: isFn ? \"expression\" : \"text\",\n        signal: val,\n        bindAttr: bA,\n    });\n    const out = isFn ? val() : val;\n    return `${hStr}<!--${bA}-->${escapeHTML(String(out))}<!--//${bA}-->`;\n}\nfunction injectArray(v, sIdx, signals, hStr, isSigArr, fn) {\n    const bind = `data-expr-${sIdx}`;\n    const signalEntry = {\n        type: \"array\",\n        signal: isSigArr\n            ? () => (v.__signal() || []).map(v.__mapFn || ((x) => x))\n            : typeof fn === \"function\"\n            ? fn\n            : () => v,\n        bindAttr: bind,\n    };\n\n    signals.set(sIdx, signalEntry);\n\n    const items = Array.isArray(v) ? v : [];\n    const out = items.map(processVal).join(\"\");\n    return `${hStr}<!--${bind}-->${out}<!--//${bind}-->`;\n}\nfunction processVal(v) {\n    if (v == null || v === false) return \"\";\n    if (Array.isArray(v)) return v.reduce((acc, x) => acc + processVal(x), \"\");\n    if (isTemplateObject(v))\n        return [...v.template.childNodes].reduce((acc, n) => {\n            if (n.nodeType === 1 && n.hasAttribute(\"key\")) {\n                n.setAttribute(\"data-key\", n.getAttribute(\"key\"));\n                n.removeAttribute(\"key\");\n            }\n            return acc + (n.outerHTML || n.textContent);\n        }, \"\");\n    if (v?.type === \"template-array\")\n        return v.templates.reduce((a, x) => a + processVal(x), \"\");\n    return escapeHTML(String(v));\n}\nfunction processTemplate(strs, ...vals) {\n    let hStr = \"\",\n        sMap = new Map(),\n        rMap = new Map();\n    let sIdx = 0,\n        rIdx = 0;\n\n    for (let i = 0; i < strs.length; i++) {\n        hStr += strs[i];\n        if (i < vals.length) {\n            const val = vals[i];\n            const aMatch = strs[i].match(attrReg);\n            const inAttr = !!aMatch;\n            const aName = aMatch?.[1];\n\n            // Inlined \"determineInjection\"\n            const refMatch = hStr.match(refReg),\n                evtMatch = hStr.match(evtReg),\n                ref = refMatch && typeof val === \"function\",\n                event = evtMatch && typeof val === \"function\",\n                evtType = evtMatch ? evtMatch[1].slice(1) : null;\n\n            if (ref) {\n                hStr = injectRef(val, hStr, rIdx++, rMap);\n            } else if (event) {\n                hStr = injectEvent(val, evtType, hStr);\n            } else if ((val?.signal || typeof val === \"function\") && inAttr) {\n                hStr = injectSignalAttr(val, aName, hStr, sIdx++, sMap);\n            } else if (Array.isArray(val) && val.__signalArray === true) {\n                hStr = injectArray(val, sIdx++, sMap, hStr, true);\n            } else if (val?.signal) {\n                hStr = injectExpr(val, false, hStr, sIdx++, sMap);\n            } else if (typeof val === \"function\") {\n                hStr = injectExpr(val, true, hStr, sIdx++, sMap);\n            } else if (Array.isArray(val)) {\n                hStr = injectArray(val, sIdx++, sMap, hStr, false, val);\n            } else if (val != null) {\n                hStr += processVal(val);\n            }\n        }\n    }\n\n    const t = document.createElement(\"template\");\n    t.innerHTML = hStr.trim();\n    return { template: t.content, signals: sMap, refs: rMap };\n}\nexport function evalExpr(fn) {\n    try {\n        return fn() ?? null;\n    } catch {\n        return null;\n    }\n}\n\nexport function html(strs, ...vals) {\n    return processTemplate(strs, ...vals);\n}\n", "import { bindEventsInRange, bindSignalToElement } from \"../helpers\";\nimport {\n    removeChildNodesBetween,\n    findCommentPlaceholders,\n    getDocumentFragment,\n} from \"../utils/dom\";\nimport { evalExpr, isTemplateObject } from \"./engine\";\nimport { reconcileArrays } from \"./reconcile\";\n\nconst cache = new Map();\n\nexport function cachedTemplate(key, fragmentOrTemplate) {\n    const content = getDocumentFragment(fragmentOrTemplate);\n    if (!cache.has(key)) cache.set(key, content.cloneNode(true));\n    return cache.get(key).cloneNode(true);\n}\n\nexport function bindPlaceholderSignal(host, { signal, bindAttr, renderer }) {\n    const [startNode, endNode] = findCommentPlaceholders(\n        host.shadowRoot,\n        bindAttr\n    );\n    if (!startNode || !endNode) return;\n    bindSignalToElement(host, signal, (newVal) =>\n        renderer(startNode, endNode, newVal)\n    );\n}\n\nexport function handleSignalBinding({ host, type, signal, bindAttr }) {\n    bindPlaceholderSignal(host, {\n        signal,\n        bindAttr,\n        renderer: (start, end, val) => {\n            const evaluated = type === \"expression\" ? evalExpr(() => val) : val;\n            if (evaluated != null) renderEvaluated(host, start, end, evaluated);\n        },\n    });\n}\n\nfunction renderEvaluated(host, start, end, val) {\n    if (Array.isArray(val) && val.some(isTemplateObject)) {\n        // Si el valor es una array de objetos de plantilla\n        reconcileArrays(\n            start,\n            end,\n            start.__oldItems || [],\n            val,\n            host\n        );\n        return;\n    }\n    const node = isTemplateObject(val)\n        ? val.template.cloneNode(true).firstElementChild\n        : document.createTextNode(String(val));\n    removeChildNodesBetween(start, end);\n    if (node) {\n        end.parentNode.insertBefore(node, end);\n        if (isTemplateObject(val)) bindEventsInRange(host, start, end);\n    }\n}\n\nexport const specialAttr = (n) =>\n    n && !/^(data-|@|ref|key$)/.test(n) && /^[a-z][\\w\\-_:]*$/i.test(n);\n", "import { useSignal } from \"../hooks/signals\";\nimport { cleanAttributeValue } from \"../utils/parser\";\nimport { specialAttr } from \"./templates\";\n\nfunction coerceAttrValue(raw) {\n    if (typeof raw !== \"string\") return raw;\n    const t = raw.trim();\n    if (!t) return t;\n    const low = t.toLowerCase(),\n        sp = {\n            true: true,\n            false: false,\n            null: null,\n            undefined: undefined,\n            nan: NaN,\n            infinity: Infinity,\n            \"-infinity\": -Infinity,\n        };\n    if (low in sp) return sp[low];\n    const num = Number(t);\n    if (!Number.isNaN(num)) return num;\n    try {\n        return JSON.parse(t);\n    } catch {\n        return t;\n    }\n}\n\nexport function generateSpecialAttrSignals(instance) {\n    for (const { name, value } of instance.attributes) {\n        if (!specialAttr(name)) continue;\n        const [signal, setSignal] = useSignal(\n            coerceAttrValue(cleanAttributeValue(value))\n        );\n        signal.set = setSignal;\n        instance._props[name] = signal;\n    }\n}\n\nexport function observeAttrMutations(instance) {\n    const obs = new MutationObserver((ms) => {\n        for (const m of ms) {\n            if (m.type !== \"attributes\" || !specialAttr(m.attributeName))\n                continue;\n            const sig = instance._props[m.attributeName];\n            if (sig?.set)\n                sig.set(\n                    coerceAttrValue(instance.getAttribute(m.attributeName))\n                );\n        }\n    });\n    obs.observe(instance, { attributes: true, attributeOldValue: true });\n    instance._cleanup.add(() => obs.disconnect());\n}\n\nexport function initPropsAndObserve(instance) {\n    generateSpecialAttrSignals(instance);\n    observeAttrMutations(instance);\n}\n", "import { Lifecycle } from \"./lifecycle\";\nimport STATE, { withCurrentComponent } from \"./globals\";\nimport { setupDeclarativeShadowRoot } from \"./utils/dom\";\nimport { initPropsAndObserve } from \"./templates/props\";\nimport { bindEventsInRange, setupSignals, setupRefs } from \"./helpers\";\nimport { cachedTemplate } from \"./templates/templates\";\n\nexport function component(name, setup) {\n    class EsorComponent extends HTMLElement {\n        constructor() {\n            super();\n            setupDeclarativeShadowRoot(this);\n            this._initInstanceState();\n            this.lifecycle = new Lifecycle();\n            STATE.currentComponent = this;\n            initPropsAndObserve(this);\n            this.lifecycle.run(\"beforeMount\", this);\n            this._render(); // Render inicial\n        }\n\n        _initInstanceState() {\n            this._cleanup = new Set();\n            this._isUpdating = false;\n            this._props = {};\n            this._eventIds = [];\n        }\n\n        connectedCallback() {\n            this.lifecycle.run(\"mount\", this);\n        }\n\n        disconnectedCallback() {\n            this.lifecycle.run(\"destroy\", this);\n            this._cleanup.forEach((fn) => fn());\n            this._cleanup.clear();\n            this._eventIds.forEach(({ type, id }) => {\n                clearEventHandler(type, id);\n            });\n            this._eventIds = [];\n        }\n\n        _render() {\n            withCurrentComponent(this, () => {\n                this.lifecycle.run(\"beforeUpdate\", this);\n                const setupResult = setup.call(this, this._props);\n                const { template, signals, refs } =\n                    typeof setupResult === \"function\"\n                        ? setupResult()\n                        : setupResult || {};\n\n                if (!this.shadowRoot.hasChildNodes()) {\n                    this.shadowRoot.appendChild(cachedTemplate(name, template));\n                }\n\n                setupSignals(this, signals);\n                bindEventsInRange(this);\n                setupRefs(this, refs);\n                this.lifecycle.run(\"update\", this);\n            });\n        }\n    }\n\n    customElements.define(name, EsorComponent);\n    return EsorComponent;\n}\n", "/**\n * useRef: devuelve un objeto mutable cuyo valor .current se asigna\n * al elemento DOM real.\n */\nexport function useRef() {\n    let ref = null;\n    return new Proxy(() => {}, {\n        apply: (_, __, [arg]) => (ref = arg),\n        get: (_, prop) => ref?.[prop]?.bind?.(ref) || ref?.[prop],\n        set: (_, prop, value) => (ref ? ((ref[prop] = value), true) : false),\n    });\n}\n", "import { useSignal } from \"./signals\";\nimport { useEffect } from \"./effects\";\n\n/**\n * useMemo: recalcula el valor solo cuando sus dependencias cambian.\n */\nexport function useMemo(fn) {\n    const [signal, setSignal] = useSignal();\n    useEffect(() => setSignal(fn()));\n    return signal;\n}\n", "import { useSignal } from \"./signals\";\nimport { useEffect } from \"./effects\";\nimport { error } from \"../logger\";\n\nconst STORAGE_PREFIX = \"esor-store:\";\n\n/**\n * useStore: peque\u00F1o store reactivo con persistencia opcional en localStorage\n */\nexport const useStore = (initialState, options = {}) => {\n    const storedState = options.persist\n        ? loadFromStorage(options.persist)\n        : null;\n\n    const [state, setState] = useSignal(storedState || initialState);\n    const subscribers = new Set();\n\n    if (options.persist) {\n        useEffect(() => {\n            const handleStorage = (e) => {\n                if (e.key === STORAGE_PREFIX + options.persist) {\n                    try {\n                        setState(JSON.parse(e.newValue));\n                    } catch (err) {\n                        error(`Failed to sync state: ${err.message}`);\n                    }\n                }\n            };\n            window.addEventListener(\"storage\", handleStorage);\n            return () => window.removeEventListener(\"storage\", handleStorage);\n        });\n    }\n\n    const store = {\n        setState(update) {\n            const newState =\n                typeof update === \"function\" ? update(state()) : update;\n            setState(newState);\n            if (options.persist) saveToStorage(options.persist, newState);\n            subscribers.forEach((cb) => cb(newState));\n        },\n        subscribe(callback) {\n            subscribers.add(callback);\n            return () => subscribers.delete(callback);\n        },\n        getState: state,\n    };\n\n    return [state, store];\n};\n\nfunction loadFromStorage(key) {\n    try {\n        const data = localStorage.getItem(STORAGE_PREFIX + key);\n        return data ? JSON.parse(data) : null;\n    } catch (e) {\n        error(`Failed to load state: ${e.message}`);\n        return null;\n    }\n}\n\nfunction saveToStorage(key, value) {\n    try {\n        localStorage.setItem(STORAGE_PREFIX + key, JSON.stringify(value));\n    } catch (e) {\n        error(`Failed to save state: ${e.message}`);\n    }\n}\n"],
  "mappings": "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",
  "names": ["_lc", "_Lifecycle_instances", "hooks_fn", "_Lifecycle", "__privateAdd", "fn", "__privateMethod", "__privateGet", "ctx", "e", "__name", "__publicField", "Lifecycle", "getLC", "beforeMount", "onMount", "beforeUpdate", "onUpdate", "onDestroy", "t", "onEffect", "clean", "STATE", "globals_default", "withCurrentComponent", "component", "prev", "valuesChanged", "val1", "val2", "getDocumentFragment", "removeChildNodesBetween", "startNode", "endNode", "node", "next", "findCommentPlaceholders", "root", "attr", "w", "s", "n", "setupDeclarativeShadowRoot", "host", "internals", "ARRAY_METHODS", "addSignalMap", "arr", "read", "method", "args", "result", "flushEffects", "effectsToRun", "effect", "useEffect", "prevEffect", "batchDepth", "pendingUpdates", "useSignal", "initialValue", "subscriptions", "value", "write", "newValue", "sub", "useComputed", "setValue", "useBatch", "escapeHTML", "match", "cleanAttributeValue", "reconcileArrays", "oldItems", "newItems", "parent", "currentNodes", "collectNodes", "newNodes", "createOrReuseNodes", "ddiff", "bindEventsInRange", "start", "end", "nodes", "current", "isValidDOMNode", "getNodeKey", "updateNodeContent", "oldNode", "newNode", "oldItem", "newItem", "oldTextNodes", "getTextNodes", "newTextNodes", "updated", "i", "len", "oldText", "newText", "textNodes", "walker", "currentNode", "items", "nodeMap", "oldItemsMap", "keys", "key", "getItemKey", "item", "existingNode", "hasChanged", "createNode", "copyEventAttributes", "oldValues", "extractDynamicValues", "newValues", "areValuesEqual", "template", "values", "fragment", "attrs", "a", "b", "val", "idx", "keysA", "keysB", "EVENT_PREFIX", "attributes", "index", "el", "keyAttr", "newList", "refNode", "aStart", "aEnd", "bStart", "bEnd", "after", "map", "sequence", "bindSignalToElement", "instance", "signal", "updateFn", "shadowRoot", "elements", "getElementsInRange", "bindEvents", "startPoint", "event", "handlerId", "eventHandler", "setupSignals", "signals", "type", "bindAttr", "attributeName", "strVal", "newVal", "oldVal", "handleSignalBinding", "setupRefs", "refs", "refFn", "STYLES", "log", "message", "capitalize", "info", "warn", "error", "eventCache", "registerEvent", "handler", "typeCache", "handlers", "id", "comp", "clearEventHandler", "useEmit", "name", "detail", "attrReg", "refReg", "evtReg", "qReg", "rawTags", "trimQuote", "getQuote", "isTemplateObject", "o", "injectRef", "hStr", "q", "injectEvent", "eType", "injectSignalAttr", "aName", "sIdx", "initVal", "escVal", "injectExpr", "isFn", "bA", "out", "injectArray", "v", "isSigArr", "bind", "signalEntry", "x", "processVal", "acc", "processTemplate", "strs", "vals", "sMap", "rMap", "rIdx", "aMatch", "inAttr", "refMatch", "evtMatch", "ref", "evtType", "evalExpr", "html", "cache", "cachedTemplate", "fragmentOrTemplate", "content", "bindPlaceholderSignal", "renderer", "evaluated", "renderEvaluated", "specialAttr", "coerceAttrValue", "raw", "low", "sp", "num", "generateSpecialAttrSignals", "setSignal", "observeAttrMutations", "obs", "ms", "m", "sig", "initPropsAndObserve", "setup", "_EsorComponent", "setupResult", "EsorComponent", "useRef", "_", "__", "arg", "prop", "useMemo", "STORAGE_PREFIX", "useStore", "initialState", "options", "storedState", "loadFromStorage", "state", "setState", "subscribers", "handleStorage", "err", "update", "newState", "saveToStorage", "cb", "callback", "data"]
}
